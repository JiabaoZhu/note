# 模板
模板定义：**模板是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数，从而实现了真正的代码可重用性。**  

模板分类：**函数模板和类模板。函数模板针对参数类型不同的函数；类模板仅针对数据成员和成员函数类型不同的类。**  

使用模板目的：**让程序员编写与类型无关的代码。**  

注意：  
*1. 模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。*  
*2. 如果在全局域中声明了与模板参数同名的变量，则该变量被隐藏掉。*  
*3. 模板参数名不能被当作类模板定义中类成员的名字。*  
*4. 同一个模板参数名在模板参数表中只能出现一次。*  
*5. 在不同的类模板或声明中，模板参数名可以被重复使用。*  
*6. 在类模板的前向声明和定义中，模板参数的名字可以不同。*  
*7. 类模板参数可以有缺省实参，给参数提供缺省实参的顺序是先右后左。*  
*8. 类模板名可以被用作一个类型指示符。当一个类模板名被用作另一个模板定义中的类型指示符时，必须指定完整的实参表。*  

***  
## 函数模板  
函数模板形式：  
```  
template <class 形参名, ...>  
返回类型 函数名(参数列表)  
{  
    函数体  
}
```  
其中 `template` 和 `class` 是关键字，`class` 可用 `typename` 关键字替代，此处 `typename` 和 `class` 没区别，`< >` 括号中的参数叫模板形参，模板形参和函数形参很像，**模板形参不能为空**。一旦声明了模板函数，就可以使用模板函数的形参名声明类中的成员变量和成员函数，即**可以在函数中使用内置类型的地方都可以使用模板形参名**。  
模板形参需要使用该模板函数时提供的模板实参来初始化模板形参，一旦编译器确定了实际的模板实参类型就称它实例化了函数模板的一个实例。  

举例：  
```  
template <class T>
void swap(T &a, T &b)
{
}
```  
当调用此模板函数时，类型 `T` 会被调用时的类型所替代。如 `swap(a, b);`  
`a` 和 `b` 为 `int` 时，模板函数 `swap` 中的形参 `T` 被 `int` 替换，模板函数为 `swap(int &a, int &b);`。  
`a` 和 `b` 为 `double` 时，模板函数 `swap` 中的形参 `T` 被 `double` 替换，模板函数为 `swap(double &a, double &b);`。  
这样便实现函数与类型无关的代码。  

注意：*对函数模板而言，不存在 `swap(int, int);` 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即 `swap(2, 3);` 或 `int a, b; swap(a, b);` 可以*。  

## 类模板  
类模板格式如下：  
```  
template <class 形参名, ...>  
class 类名  
{  
    ...  
};
```  
类模板也是以 `template` 开始，后接模板参数列表，**模板参数不能为空**，一旦声明了类模板，**就可以使用类模板的形参名声明类中的成员变量和成员函数**，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。  

举例：  
```
template <class T>  
class A  
{  
public:  
    T a;  
    T b;  
    T add(T c, T &d);  
};  
```  

类模板对象的创建：如模板类 `A`，使用模板类创建对象的方法： `A<int> m;`。在类 `A` 后面跟上 `< >` 尖括号并在里面填上相应类型，这样类 `A` 中凡是用到模板形参的地方，都会被 `int` 所代替。当类模板有两个模板形参时，创建对象方法为 `A<int, double> m;`，类型中间用逗号隔开。  

注意：*对于类模板，模板形参类型必须在类型后的尖括号中明确指定。使用 `A<2>` 错误，原因是类模板形参不存在实参推演的问题。*  

在类模板外部定义成员函数方法：  
```  
template <class 形参名, ...>  
返回类型 类名<模板形参名>::函数名(参数列表)  
{  
    函数体  
}  
```  
举例：  
假如有两个模板形参 `T1`，`T2` 的类 `A`，含有 `void add()` 函数，则定义该函数方法：  
```  
template <class T1, class T2>  
void A<T1, T2>::add()  
{  
}  
```  

注意：*在类外定义类的成员时， `template` 后面的模板形参应与要定义的类的模板形参一致。模板的声明或定义只能在全局，命名空间或类范围内进行。不能在局部范围，函数内进行。*  

## 模板形参  
类型：**类型形参，非类型形参，模板形参。**  
### 类型形参  
类型形参：**由关键字 `class` 或 `typename` 后接说明符构成**，如：  
```  
template<T>  
void h(T a)  
{  
}  
```  
其中 `T` 就是类型形参，类型形参名可由用户自己确定。不能为同一个模板类型形参指定两种不同的类型。对函数，直接报错，对类中函数，则可能计算出错。  
### 非类型形参  
非类型模板形参：**模板的非类型形参也就是内置类型形参**，如：  
```  
template <class T, int a>  
class B  
{  
};  
```  
其中 `int a` 就是非类型的模板形参。  
注意：  
1. 非类型形参在模板定义的内部是常量值，即说非类型形参在模板的内部是常量。  
2. 非类型模板的形参只能是整型，指针和引用，如 `double`，`string`，`string *` 等都不允许。但 `double`，`double &`，对象引用或指针可以。  
3. 调用非类型模板形参的实参必须是一个常量表达式，即必须在编译时计算出结果。  
4. 注意：任何局部对象，局部变量，局部对象地址，局部变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针，全局变量，全局对象也不是常量表达式，不能做非类型模板形参的实参。  
5. 全局变量的地址或引用，全局对象的地址或引用 `const` 类型变量是常量表达式，可以用作非类型模板形参的实参。  
6. `sizeof()` 表达式结果为常量表达式，可做非类型模板形参的实参。  
7. 当模板形参时整型时，调用该模板时的实参必须为整型，且编译期间是常量，如对 `template <class T, int a> class A { }`，若有 `int b，A< int, b> m` 出错，因为 `b` 不是常量，当为 `const int b`，且 `b` 的值在编译期可确定，则正确。  
8. 非类型形参一般不应用与函数模板中，如 `template <class T, int a> void h(T b) { }`，使用 `h(2);` 错误。解决方法：使用显示模板实参，用 `h<int, 3>(2);` 能实现把非类型形参 `a` 设置为整数 3 。  
9. 非类型模板形参的形参与实参之间允许转换情况：  
    * 允许从数组到指针，从函数到指针的转换。举例：`template <int *a> class A { }; int b[1]; A<b> m;`，数组到指针转换。  
    * `const` 修饰符的转换。举例：`template <const int a> class A { }; int b; A<&b> m;`，`int` 到 `const int *` 转换。  
    * 提升转换。举例：`template <int a> class A { }; const short b = 2; A<b> m;`，从 `short` 到 `int` 提升转换。  
    * 数值转换。举例：`template <unsinged int a> class A { }; A<2> m;`，从 `int` 到 `unsigned int` 转换。  
    * 常规转换。  

### 模板形参
模板形参表示一个未知的类型。模板类型形参可作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用完全相同，即可以用于指定返回类型，变量声明等。  

## 模板实例化  
模板实例化是一个过程，它根据泛型的模板定义，生成（具体的）类型或者函数。  


## 模板具体化

***  
引用自：
> [http://www.cnblogs.com/assemble8086/archive/2011/10/02/2198308.html](http://www.cnblogs.com/assemble8086/archive/2011/10/02/2198308.html)  
> [http://blog.csdn.net/yzhang6_10/article/details/50839516](http://blog.csdn.net/yzhang6_10/article/details/50839516)