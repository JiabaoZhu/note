# trivial destructor  
如果用户不定义析构函数，而是用系统自带的，则说明，析构函数基本没有什么用（但默认会被调用）我们称之为 trivial destructor 。反之，如果特定定义了析构函数，则说明需要在释放空间之前做一些事情，则这个析构函数称为 non-trivial destructor 。如果某个类中只有基本类型的话是没有必要调用析构函数的，`delelte p;` 的时候基本不会产生析构代码。  

在类中如果只有基本的数据类型，也就不需要写显式的析构函数，即用默认析构函数就够用了，但是如果类中有个指向其他类的指针，并且在构造时候分配了新的空间，则在析构函数中必须显式释放这块空间，否则会产生内存泄露。  

在 STL 中空间配置时，`destory()` 函数会判断要释放的迭代器的指向的对象有没有  trivial destructor(STL 中有一个 `has_trivial_destructor` 函数，很容易实现检测)，如果有 trivial destructor 则什么都不做，如果没有即需要执行一些操作，则执行真正的 `destory()` 函数。  

`destory()` 有两个版本，第一个版本接受一个指针，准备将该指针所指之物析构掉。第二个版本接受 `first` 和 `last` 两个迭代器，准备将 `[first, last]` 范围内的所有对象析构掉。我们不知道这个范围有多大，万一很大，而每个对象的析构函数都无关痛痒，那么一次次调用这些析构函数，对效率是一种伤害，因此这里首先利用 `value_type()` 获得迭代器所指对象的类别，再利用 `_type_traits<T>` 判断该型别的析构函数是否无关痛痒，若是 (`_true_type`)，则什么也不做就结束；若否 (`_false_type`)，这才以循环的方式巡访整个范围，并在循环中每经历一个对象就调用第一个版本的 `destory()` 函数。  
